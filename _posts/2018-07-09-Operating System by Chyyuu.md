---
title: Operating System by Chyyuu
layout: post
tags: cs
---

# 实验总体流程

1. 在[学堂在线](https://www.xuetangx.com/courses/TsinghuaX/30240243X/2015_T1/about)查看OS相关原理和labX的视频；
2. 在[实验指导书 on gitbook](https://chyyuu.gitbooks.io/ucore_os_docs/content/)上阅读实验指导书，并参考其内容完成练习和实验报告；
3. 在实验环境中完成实验并提交实验到git server（清华学生需要在学校内部的git server上，其他同学可提交在其他git server上）；
4. 如实验中碰到问题，在[在线OS课程问题集](https://chyyuu.gitbooks.io/os_course_qa/content/)查找是否已经有解答；
5. 如没有解答，可在[piazza在线OS课程问答和交流区](https://piazza.com/tsinghua.edu.cn/spring2015/30240243x/home)提问,每天（一周七日）都有助教或老师在piazza在线答疑。（QQ群 181873534主要用于OS课程一般性交流）；
6. 可进一步在[学堂在线](https://www.xuetangx.com/courses/TsinghuaX/30240243X/2015_T1/about)或[在线的操作系统课程练习题](https://chyyuu.gitbooks.io/os_course_exercises/content/)完成实验相关的练习题；

# 第一章 操作系统概述

## 1.1 课程概述
- 大纲
    - 基本概念
    - 操作系统介绍
    - 中断及系统调用
    - 内存管理
    - 进程和线程
    - 调度
    - 同步
    - 文件系统
    - I/O子系统
- 实验环境：

    - uCore操作系统
    - https://github.com/chyyuu/mooc_os_lab
    - https://github.com/chyyuu/os_course_info
    - https://www.shiyanlou.com/courses/221
    - 8个实验
      - 准备
      - 系统启动及中断
      - 物理内存管理
      - 虚拟内存管理
      - 内核线程管理
      - 用户进程管理
      - CPU调度
      - 同步与互斥
      - 文件系统
- 预备知识
    - 计算机结构原理
    - 数据结构
    - C语言和汇编语言

## 1.2 什么是操作系统

- 定义

  - 用户角度上，操作系统是一个控制软件

  - 管理应用程序

  - 为应用程序提供服务

  - 杀死应用程序

  - 资源管理

  - 管理外设、分配资源

    《图》

- 组成

  - shell 外壳

    如GUI、命令行

  - kernel 内核

    - **CPU**调度器
    - 物理**内存**管理
    - 虚拟**内存**管理
    - **文件**系统管理
    - 中断处理与**设备**驱动

- kernel的特征

  - 并发：系统中同时存在多个运行的程序，需要OS管理和调度
  - 共享：同时访问、互斥共享
  - 虚拟：让每个用户都认为有一个计算机专门为他服务
  - 异步：程序的执行不是一贯到底，而是走走停停

## 1.3 为什么学习操作系统

老师说因为很酷，我只想糊口。

## 1.4 如何学习操作系统

老师说要实践。

## 1.5 操作系统实例

- UNIX

  UNIX BSD(伯克利软件发行版) 进行了拓展

  hp, IBM, iOS

- Linux

  redhat, fedore, ubuntu, oepnSUSE, debian

  Android

- Windows

  DOS演变来的

## 1.6 操作系统的历史

   反正就是越来越牛逼了。

## 1.7 操作系统结构

有很多种架构。

##### 【实验一 bootloader启动ucore os】

# 第二章 启动、中断、异常和系统调用

## 2.1 操作系统的启动

- 内存中：

  - **BIOS**: 基本I/O处理系统

    位置：CS:IP = 0xf000:fff0 (段寄存器：指令寄存器)

    作用：将Bootloader从硬盘的引导扇区加载到0x7c00

    第一步：POST（加电自检）：寻找显卡和执行BIOS

- 硬盘中：

  - **Bootloader**: 加载OS 

    在第一个主引导扇区：512字节

    作用：

    1. 将硬盘中的OS加载到内存中
    2. 跳转到OS的起始地址

  - **OS**

    《图》

- 操作系统的接口

  |      | 中断                | 异常                  | 系统调用              |
  | ---- | ----------------- | ------------------- | ----------------- |
  | 定义   | 不同的硬件设备的计时器和网络的中断 | 非法指令或者其他坏的处理状态      | 应用程序主动向操作系统发出服务请求 |
  | 来源   | 来自外设              | 来自不良的应用程序           | 来自应用程序            |
  | 处理时间 | 异步                | 同步                  | 异步或同步             |
  | 响应   | 持续，对用户应用程序是透明的    | 杀死或者重新执行意想不到的应用程序指令 | 等待和持续             |

- 权限

  - 内核是被信任的第三方软件

  - 只有内核可以执行特权指令

  - 为了方便应用程序，使上层应用不用关注底层的差异性


## 2.2 中断、异常和系统调用

- 中断

  - 硬件
    1. 将内部、外部事件设置中断标记
    2. 中断事件的ID
  - 软件
    1. 保存当前处理状态
    2. 中断服务程序处理
    3. 清除中断标记
    4. 恢复之前保存的处理状态

- 异常

  - 保存现场
  - 异常处理
    - 杀死产生异常的程序
    - 重新执行异常指令
  - 恢复现场

- 系统调用

  | Windows             | Win32 API |
  | ------------------- | --------- |
  | UNIX, LINUX, MAC OS | POSIX API |
  | JAVA 虚拟机            | Java API  |

- 跨越操作系统边界的多余的开销

  1. 建立中断/异常/系统调用号与对应服务例程映射关系的初始化
  2. 建立内核堆栈
  3. 验证参数
  4. 内核态映射到用户态的地址空间
  5. 内核态独立地址空间

# 第三章  物理内存管理: 连续内存分配

## 3.1 计算机体系结构及内存分层体系

- 计算机体系结构

  - **CPU**：运算器、寄存器、控制器、缓存Cache、存储管理单元MMU

  - **内存**：

    - 抽象

      逻辑地址空间

    - 保护

      独立地址空间

    - 共享

      访问相同内存

    - 虚拟化

      更多的地址空间

  - **I/O设备**

- 操作系统中管理内存的不同方法

  - 程序重定位
  - 分段
  - 分页
  - 虚拟内存
  - 按需分页虚拟内存

- 管理内存依赖于硬件

  - 内存架构
  - MMU内存管理单元：硬件组件负责处理CPU的内存访问请求

## 3.2 地址空间与地址生成

- 地址空间定义
  - 物理地址空间：主存、磁盘
  - 逻辑地址空间：一个运行的程序所拥有的的内存范围

- 地址生成

  ​	编译 -> 汇编 -> 链接-> 载入 

  c语言 -> 汇编 -> 机器 -> 执行文件

  内存管理单元MMU中有一种映射关系（逻辑地址<- >物理地址）

  1. CPU中的计算逻辑单元ALU发出请求，获得逻辑地址
  2. CPU中的内存管理单元MMU查找映射表找到物理地址
  3. CPU中的控制器丛广宗县发送在物理地址的主存内容的请求
  4. 主存发送物理地址主存的内容给CPU

- 地址安全检查

  界限寄存器：起始地址

  基址寄存器：长度

## 3.3 连续内存分配：内存碎片与分区的动态分配

- 内存碎片问题

  - 外部碎片

    在分配单元间的未使用内存

  - 内部碎片

    在分配单元中的未使用内存（应用程序没法对分配的内存进行使用）

- 分区的动态分配

  - 第一适配

    为了分配n个字节，使用第一个可用空闲块，块的尺寸比n大

    回收的时候需要检查，看是否能合并相邻的空闲分区

  - 最佳适配

    为了分配n字节，使用最小的可用空闲块，块的尺寸比n大

    优点：避免风格大空闲块，最小化外部碎片产生的尺寸

  - 最差适配

    为了分配n字节，使用最大的可用空闲块，块的尺寸比n大

    优点：避免有太多微小的碎片

## 3.4 连续内存分配：压缩式与交换式碎片整理

- 压缩式碎片整理

  重置程序以合并空洞

  要求所有程序是动态可重置的

- 交换式碎片整理

  使用磁盘作为虚拟内存

# 第四章 物理内存管理: 非连续内存分配

## 4.1 非连续内存分配：分段

- 概念

  一个逻辑地址空间

- 访问地址

  需要一个二维的二元组 (s-段号, addr-段内偏移)

- 方案

  1. CPU获取到二元组 (s-段号, addr-段内偏移)
  2. 段号在段表内找到映射关系(逻辑空间起始地址->物理空间起始地址)
  3. 段表内的limit值在MMU中预算，进行内存异常检测
  4. MMU中找到物理地址

## 4.2 非连续内存分配：分页

- 划分物理内存至固定大小的**帧**（物理，**frame**）

  帧：一个内存物理地址是一个二元组 (f-帧号, o-帧内偏移)

  帧号：F位，工有$2^F$个帧

  帧内偏移：S位，每帧有$2^S$字节
  $$
  物理地址 = f×2^s+o
  $$

- 划分逻辑地址空间至相同大小的**页**（逻辑，**page**）

  页：一个逻辑地址是一个二元组(p-页号, o-页内偏移)

  页内偏移的大小 = 帧内偏移的大小

  页号大小 不一定等于 帧号大小

- 建立方案：转换逻辑地址为物理地址

  - 页表

    根据页号p 可以找到 帧号f

    因为offset一样，所以就可以计算出物理地址

  - MMU/TLB

## 4.3 非连续内存分配：页表-TLB

- 页表

  每个运行的程序都有一个页表

  页表属于程序运行状态，会动态变化

  PTBR: 页表基址寄存器

  页表项内容：

  - Flags标志位：

    dirty bit,     

    resident bit,     #页表是否合法（存在）

    clock/reference bit,

  - 帧号：f

- TLB

  Translation Look-aside Buffer

  位于CPU内部

  用途：缓存近期访问的页帧转换表项

  - TLB使用关联内存实现，具备快速访问性能
  - 如果TLB命中，物理页号可以很快被获取
  - 如果TLB未命中，对应的表项被更新到TLB中（要去页表查）

  结构 ：{key: p , value: f}

  把经常用到的页表项放入TLB中

## 4.4 非连续内存分配：页表-二级、多级页表

- 二级页表

  page number 拆分为 p1 和 p2

  p1: 一级页表

- 多级页表

  二级页表的推广

## 4.5 非连续内存分配：页表-反向页表

- 基于页寄存器(Page Registers)的方案

  根据物理页号找到页帧号，寄存器容量只和物理地址空间有关

  寄存器内容：

  - Residence bit：此帧是否被占用 
  - Occupier：对应的页号p
  - Protection bits：保护位

- 基于关联内存(associative memory)的方案

  局限性：运算复杂，所需时间长，耗电

- 基于哈希(hash)查找的方案

  有一个哈希表，使用PID来缓解哈希碰撞

##### 【实验二 物理内存管理】

# 第五章 虚拟存储概念

# 第六章 页面置换算法

##### 【实验三 虚拟内存管理】

# 第七章 进程和线程

# 第八章 进程控制

##### 【实验四 内核线程管理】

##### 【实验五 用户进程管理】

# 第九章 处理机调度

##### 【实验六 调度器】

# 第十章 同步互斥

# 第十一章 信号量与管程 

##### 【实验七 同步互斥】

# 第十二章 死锁和进程通信

# 第十三章 文件系统

##### 【实验八 文件系统】

# 第十四章 I/O子系统